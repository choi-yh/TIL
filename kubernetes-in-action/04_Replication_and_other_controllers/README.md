# Index
* [4.레플리케이션과 그 밖의 컨트롤러: 관리되는 파드 배포](#4레플리케이션과-그-밖의-컨트롤러--관리되는-파드-배포)
* [4.1 파드를 안정적으로 유지하기](#41-파드를-안정적으로-유지하기)
  * [4.1.1 라이브니스 프로브 소개](#411-라이브니스-프로브-소개)
  * [4.1.2 HTTP 기반 라이브니스 프로브 생성](#412-http-기반-라이브니스-프로브-생성)
  * [4.1.3 동작 중인 라이브니스 프로브 확인](#413-동작-중인-라이브니스-프로브-확인)
  * [4.1.4 라이브니스 프로브의 추가 설정](#414-라이브니스-프로브의-추가-설정)
  * [4.1.5 효과적인 라이브니스 프로브 생성](#415-효과적인-라이브니스-프로브-생성)
* [4.2 레플리케이션컨트롤러 소개](#42-레플리케이션컨트롤러-소개)
  * [4.2.1 레플리케이션컨트롤러의 동작](#421-레플리케이션컨트롤러의-동작)
  * [4.2.2 레플리케이션컨트롤러 생성](#422-레플리케이션컨트롤러-생성)
  * [4.2.3 레플리케이션컨트롤러 작동 확인](#423-레플리케이션컨트롤러-작동-확인)
  * [4.2.4 레플리케이션컨트롤러의 범위 안팎으로 파드 이동하기](#424-레플리케이션컨트롤러의-범위-안팎으로-파드-이동하기)
  * [4.2.5 파드 템플릿 변경](#425-파드-템플릿-변경)
  * [4.2.6 수평 파드 스케일링](#426-수평-파드-스케일링)
  * [4.2.7 레플리케이션컨트롤러 삭제](#427-레플리케이션컨트롤러-삭제)

---

# [4.레플리케이션과 그 밖의 컨트롤러: 관리되는 파드 배포](#Index)

> * 파드의 안정적인 유지  
> * 동일한 파드의 여러 인스턴스 실행  
> * 노드 장애 시 자동으로 파드 재스케줄링  
> * 파드의 수평 스케줄링  
> * 각 클러스터 노드에서 시스템 수준의 파드 실행  
> * 배치 잡 실행  
> * 잡을 주기적 또는 한 번만 실행하도록 스케줄링

* 쿠버네티스에서 파드는 배포 가능한 기본 단위
* 파드를 직접 생성하지 않고 레플리케이션 컨트롤러나 디플로이먼트와 같은 유형의 리소스를 생성해 실제 파드를 생성하고 관리한다.
* 노드 전체에 장애가 발생하면 노드에 있는 파드는 유실된다.
* 레플리케이션컨트롤러나 이와 유사한 기능을 하는 컨트롤러가 해당 파드를 관리하지 않는 한 새로운 파드로 대체되지 않는다.

---

# [4.1 파드를 안정적으로 유지하기](#Index)

* 쿠버네티스 사용의 주요 이점 : 쿠버네티스에 컨테이너 목록을 제공하면 해당 컨테이너를 클러스터 어딘가에서 계속 실행되도록 할 수 있다는 것
* 파드 리소스를 생성하고 쿠버네티스가 이 파드를 실행 할 워커 노드를 지정하며 해당 노드에서 파드의 컨테이너가 실행되도록 함으로써 이 작업을 수행


* 파드가 노드에 스케줄링되는 즉시, 해당 노드의 Kubelet 은 파드의 컨테이너를 실행하고 파드가 존재하는 한 컨테이너가 계속 실행되도록 한다.
* 컨테이너의 주 프로세스에 crash 가 발생하면 Kubelet 이 컨테이너를 재시작한다.
* 애플리케이션이 메모리 누수와 같은 상황으로 크래시 없이 프로세스가 중단되는 경우가 있다.
  * 이 경우, 쿠버네티스가 애플리케이션을 재시작하는 방법이 필요

## [4.1.1 라이브니스 프로브 소개](#Index)

* 쿠버네티스는 liveness probe 를 통해 컨테이너가 살아있는지 확인 가능
* 파드의 스펙 (specification) 에 각 컨테이너의 라이브니스 프로브 지정 가능
* 라이브니스 프로브 실행 메커니즘
  1. HTTP GET 프로브
     * 수신 코드로 확인 (2xx, 3xx 아닐 경우 실패 판단 -> 컨테이너 재실행)
  2. TCP 소켓 프로브
     * 컨테이너의 지정된 포트에 TCP 연결 시도 성공 여부로 판단
  3. Exec 프로브
     * 컨테이너 내의 임의의 명령 실행 -> 상태 코드 확인 (0일 경우 성공)


## [4.1.2 HTTP 기반 라이브니스 프로브 생성](#Index)
`./kubia-liveness-probe.yaml`


## [4.1.3 동작 중인 라이브니스 프로브 확인](#Index)

```markdown
 Last State:     Terminated
      Reason:       Error
      Exit Code:    143
      Started:      Sat, 08 Jul 2023 15:50:23 +0900
      Finished:     Sat, 08 Jul 2023 15:51:40 +0900
```
* `kubectl describe pod` 에서 확인되는 `Exit Code` 는 프로세스가 외부 신호에 의해 종료됐음을 나타낸다.
* 128 + x 값으로 x 는 프로세스에 전송된 시그널 번호이며 이 시그널로 인해 컨테이너가 종료됨
  * signal number 15 는 `SIGTERM` (Signal + Terminate)


## [4.1.4 라이브니스 프로브의 추가 설정](#Index)
```markdown
Liveness:       http-get http://:8080/ delay=0s timeout=1s period=10s #success=1 #failure=3
```

* `delay=0s`
  * 컨테이너 시작 후 바로 프로브 시작
  * 애플리케이션 시작 시간을 고려해서 설정해야 한다.
* `timeout=1s`: 컨테이너는 1초 이내 응답해야함
* `period=10s`: 10초마다 프로브 수행
* `failure=3`: 3번 실패시 컨테이너 재시작


## [4.1.5 효과적인 라이브니스 프로브 생성](#Index)

### 라이브니스 프로브가 확인해야 할 사항
* *단순히 서버가 응답을 하는지만 하는 라이브니스 프로브*라도 있는 것이 좋다.
* 더 나은 라이브니스 프로브를 위해 특정 URL 경로 (ex. `/health`) 에 요청하도록 프로브를 구성해 애플리케이션 내에서 실행 중인 모든 주요 구성 요소가 살아 있는지 또는 응답이 없는지 확인하도록 구성할 수 있다.
  * HTTP 엔드포인트에 인증이 필요한지 유무도 확인해야 함

### 프로브를 가볍게 유지하기
* 라이브니스 프로브는 너무 많은 연산 리소스를 사용해서는 안 되며, 완료하는데 너무 오래 걸리지 않아야 한다.
* 기본적으로 프로브는 비교적 자주 실행되며 1초 내에 완료돼야 한다.

### 프로브에 재시도 루프를 구현하지 마라
* 프로브에 자체적인 재시도 루프를 구현하는 것은 헛수고다.

### 라이브니스 프로브 요약
* 라이브니스 프로브 실패시 컨테이너 재실행은 파드를 호스팅하는 노드의 Kubelet 에서 수행
  * 마스터에서 실행 중인 쿠버네티스 컨트롤 플레인 구성 요소는 이 프로세스에 관여하지 않는다.
* 노드 자체에 크래시가 발생한 경우 노드 크래시로 중단된 모든 파드의 대체 파드를 생성해야 하는 것은 컨트롤 플레인의 역할
* 직접 생성한 파드는 Kubelet 에 의해서 관리되는데, Kubelet 은 노드에서 실행되기 때문에 노드가 고장나면 아무것도 못한다.
* 애플리케이션이 다른 노드에서 재시작되도록 하려면 레플리케이션컨트롤러 등으로 파드를 관리해야 한다.

---

# [4.2 레플리케이션컨트롤러 소개](#Index)
* 레플리케이션컨트롤러는 파드 개수를 탐지하고, 항상 정해진 수의 파드를 유지한다.
![figure 4.1.png](figures/figure%204.1.png)


## [4.2.1 레플리케이션컨트롤러의 동작](#Index)
* 레플리케이션컨트롤러는 파드 유형이 아니라 특정 레이블 셀렉터 (label selector)와 일치하는 파드 세트에 작동한다.

### 컨트롤러 조정 루프
![figure 4.2.png](figures/figure%204.2.png)

### 레플리케이션컨트롤러의 세 가지 요소 이해
* `label selector` : 레플리케이션컨트롤러 범위에 있는 파드 결정
* `replica count` : 실행 할 파드의 수
* `pod template` : 새로운 파드 레플리카를 만들 때 사용

![figure 4.3.png](figures/figure%204.3.png)

### 컨트롤러의 레이블 셀렉터 또는 파드 템플릿 변경의 영향 이해
* 레이블 셀렉터나 파드 템플릿이 변경되면 레플리케이션컨트롤러는 기존 파드에 대한 관리를 중지한다.
* 따라서 정해진 파드의 수가 맞지 않기 떄문에 새로운 파드를 생성한다.

### 레플리케이션컨트롤러 사용 시 이점
* 기존 파드가 사라지면 새 파드를 시작해 파드가 항상 실행되도록 한다.
* 클러스터 노드에 장애가 발생하면 장애가 발생한 노드에서 실행 중인 모든 파드에 대한 교체 복제본이 생성된다.
* 수동 또는 자동으로 파드를 쉽게 수평 확장 가능하다.


## [4.2.2 레플리케이션컨트롤러 생성](#Index)


## [4.2.3 레플리케이션컨트롤러 작동 확인](#Index)

```markdown
❯ kubecolor describe rc kubia

Name:         kubia
Namespace:    default
Selector:     app=kubia
Labels:       app=kubia
Annotations:  <none>
Replicas:     3 current / 3 desired # 실제 파드 수 / 의도하는 인스턴스 수
Pods Status:  3 Running / 0 Waiting / 0 Succeeded / 0 Failed # 파드 상태별 인스턴스 수
Pod Template:
  Labels:  app=kubia
  Containers:
   kubia:
    Image:        hyooo/kubia
    Port:         8080/TCP
    Host Port:    0/TCP
    Environment:  <none>
    Mounts:       <none>
  Volumes:        <none>
Events: # 레플리케이션컨트롤러 관련 이벤트 - 현재까지 파드를 4개 생성했다.
  Type    Reason            Age    From                    Message
  ----    ------            ----   ----                    -------
  Normal  SuccessfulCreate  2m11s  replication-controller  Created pod: kubia-tp2c2
  Normal  SuccessfulCreate  2m11s  replication-controller  Created pod: kubia-9jbz7
  Normal  SuccessfulCreate  2m11s  replication-controller  Created pod: kubia-z5g67
  Normal  SuccessfulCreate  44s    replication-controller  Created pod: kubia-klkck
```

### 컨트롤러가 새로운 파드를 생성한 원인 정확히 이해하기
* 레플리케이션컨트롤러는 파드 삭제 그 자체에 대응한 것이 아니라 **결과적인 상태 (부족한 파드 수)** 에 대응하는 것
![figure 4.4.png](figures/figure%204.4.png)


## [4.2.4 레플리케이션컨트롤러의 범위 안팎으로 파드 이동하기](#Index)
* 레플리케이션컨트롤러는 레이블 셀렉터와 일치하는 파드만 관리한다.

### 레플리케이션컨트롤러가 관리하는 파드에 레이블 추가
```markdown
❯ kubecolor get pods

NAME          READY   STATUS    RESTARTS   AGE
kubia-9jbz7   1/1     Running   0          7m39s
kubia-klkck   1/1     Running   0          6m12s
kubia-tp2c2   1/1     Running   0          7m39s
```
```shell
kubectl label pod kubia-tp2c2 type=special
kubecolor get pods --show-labels
kubectl label pod kubia-tp2c2 app=foo --overwrite
kubecolor get pods -L app
```

![figure 4.5.png](figures/figure%204.5.png)

### 레플리케이션컨트롤러의 레이블 셀렉터 변경
* Q) 파드의 레이블을 변경하는 대신 레플리케이션컨트롤러의 레이블 셀렉터를 수정하면 어떻게 될까?
  * Me) 수정된 레이블 셀렉터로 파드를 다시 생성하지 않을까?
  * Author) 모든 파드가 레플리케이션컨트롤러의 범위를 벗어나게 되기 때문에 세 개의 새로운 파드를 생성하게 될 것이다.


## [4.2.5 파드 템플릿 변경](#Index)
* 기존 파드를 수정하려면 해당 파드를 삭제하고 레플리케이션컨트롤러가 새 템플릿을 기반으로 새 파드로 교체하도록 해야 한다.
![figure 4.6.png](figures/figure%204.6.png)
1. 파드 템플릿 변경
2. 기존 파드 삭제
3. 새로운 파드 템플릿으로 rc가 파드 생성


## [4.2.6 수평 파드 스케일링](#Index)
* 파드 수를 늘리거나 줄이는 것은 레플리케이션컨트롤러 리소스의 *replicas* 필드 값을 변경하면 된다.

### 레플리케이션컨트롤러 스케일 업 & 다운 하기
```shell
kubectl scale rc kubia --replicas=10 # 스케일업
kubectl edit rc kubia # edit command 를 통해 replicas 값을 변경해준다.
kubectl scale rc kubia --replicas=3 # 스케일 다운
```

`kubectl scale` 명령은 쿠버네티스에게 무언가를 하라고 알려주는 게 아니라 레플리케이션컨트롤러의 의도하는 상태 (desired states) 를 선언적으로 변경 한다는 것이 훨씬 명확해 보인다.

### 스케일링에 대한 선언적 접근 방법 이해
* 쿠버네티스에게 무엇을 어떻게 하라고 말하는게 아니라 의도하는 상태를 지정할 뿐이다.


### [4.2.7 레플리케이션컨트롤러 삭제](#Index)
![figure 4.7.png](figures/figure%204.7.png)
* 레플리케이션컨트롤러만 삭제하고 파드는 삭제하지 않기