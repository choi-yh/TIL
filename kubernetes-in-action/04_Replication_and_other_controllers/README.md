# Index
* [4.레플리케이션과 그 밖의 컨트롤러: 관리되는 파드 배포](#4레플리케이션과-그-밖의-컨트롤러--관리되는-파드-배포)
* [4.1 파드를 안정적으로 유지하기](#41-파드를-안정적으로-유지하기)
  * [4.1.1 라이브니스 프로브 소개](#411-라이브니스-프로브-소개)
  * [4.1.2 HTTP 기반 라이브니스 프로브 생성](#412-http-기반-라이브니스-프로브-생성)
  * [4.1.3 동작 중인 라이브니스 프로브 확인](#413-동작-중인-라이브니스-프로브-확인)
  * [4.1.4 라이브니스 프로브의 추가 설정](#414-라이브니스-프로브의-추가-설정)
  * [4.1.5 효과적인 라이브니스 프로브 생성](#415-효과적인-라이브니스-프로브-생성)

---

# [4.레플리케이션과 그 밖의 컨트롤러: 관리되는 파드 배포](#Index)

> * 파드의 안정적인 유지  
> * 동일한 파드의 여러 인스턴스 실행  
> * 노드 장애 시 자동으로 파드 재스케줄링  
> * 파드의 수평 스케줄링  
> * 각 클러스터 노드에서 시스템 수준의 파드 실행  
> * 배치 잡 실행  
> * 잡을 주기적 또는 한 번만 실행하도록 스케줄링

* 쿠버네티스에서 파드는 배포 가능한 기본 단위
* 파드를 직접 생성하지 않고 레플리케이션 컨트롤러나 디플로이먼트와 같은 유형의 리소스를 생성해 실제 파드를 생성하고 관리한다.
* 노드 전체에 장애가 발생하면 노드에 있는 파드는 유실된다.
* 레플리케이션컨트롤러나 이와 유사한 기능을 하는 컨트롤러가 해당 파드를 관리하지 않는 한 새로운 파드로 대체되지 않는다.

---

# [4.1 파드를 안정적으로 유지하기](#Index)

* 쿠버네티스 사용의 주요 이점 : 쿠버네티스에 컨테이너 목록을 제공하면 해당 컨테이너를 클러스터 어딘가에서 계속 실행되도록 할 수 있다는 것
* 파드 리소스를 생성하고 쿠버네티스가 이 파드를 실행 할 워커 노드를 지정하며 해당 노드에서 파드의 컨테이너가 실행되도록 함으로써 이 작업을 수행


* 파드가 노드에 스케줄링되는 즉시, 해당 노드의 Kubelet 은 파드의 컨테이너를 실행하고 파드가 존재하는 한 컨테이너가 계속 실행되도록 한다.
* 컨테이너의 주 프로세스에 crash 가 발생하면 Kubelet 이 컨테이너를 재시작한다.
* 애플리케이션이 메모리 누수와 같은 상황으로 크래시 없이 프로세스가 중단되는 경우가 있다.
  * 이 경우, 쿠버네티스가 애플리케이션을 재시작하는 방법이 필요

## [4.1.1 라이브니스 프로브 소개](#Index)

* 쿠버네티스는 liveness probe 를 통해 컨테이너가 살아있는지 확인 가능
* 파드의 스펙 (specification) 에 각 컨테이너의 라이브니스 프로브 지정 가능
* 라이브니스 프로브 실행 메커니즘
  1. HTTP GET 프로브
     * 수신 코드로 확인 (2xx, 3xx 아닐 경우 실패 판단 -> 컨테이너 재실행)
  2. TCP 소켓 프로브
     * 컨테이너의 지정된 포트에 TCP 연결 시도 성공 여부로 판단
  3. Exec 프로브
     * 컨테이너 내의 임의의 명령 실행 -> 상태 코드 확인 (0일 경우 성공)


## [4.1.2 HTTP 기반 라이브니스 프로브 생성](#Index)
`./kubia-liveness-probe.yaml`


## [4.1.3 동작 중인 라이브니스 프로브 확인](#Index)

```markdown
 Last State:     Terminated
      Reason:       Error
      Exit Code:    143
      Started:      Sat, 08 Jul 2023 15:50:23 +0900
      Finished:     Sat, 08 Jul 2023 15:51:40 +0900
```
* `kubectl describe pod` 에서 확인되는 `Exit Code` 는 프로세스가 외부 신호에 의해 종료됐음을 나타낸다.
* 128 + x 값으로 x 는 프로세스에 전송된 시그널 번호이며 이 시그널로 인해 컨테이너가 종료됨
  * signal number 15 는 `SIGTERM` (Signal + Terminate)


## [4.1.4 라이브니스 프로브의 추가 설정](#Index)
```markdown
Liveness:       http-get http://:8080/ delay=0s timeout=1s period=10s #success=1 #failure=3
```

* `delay=0s`
  * 컨테이너 시작 후 바로 프로브 시작
  * 애플리케이션 시작 시간을 고려해서 설정해야 한다.
* `timeout=1s`: 컨테이너는 1초 이내 응답해야함
* `period=10s`: 10초마다 프로브 수행
* `failure=3`: 3번 실패시 컨테이너 재시작


## [4.1.5 효과적인 라이브니스 프로브 생성](#Index)

### 라이브니스 프로브가 확인해야 할 사항
* *단순히 서버가 응답을 하는지만 하는 라이브니스 프로브*라도 있는 것이 좋다.
* 더 나은 라이브니스 프로브를 위해 특정 URL 경로 (ex. `/health`) 에 요청하도록 프로브를 구성해 애플리케이션 내에서 실행 중인 모든 주요 구성 요소가 살아 있는지 또는 응답이 없는지 확인하도록 구성할 수 있다.
  * HTTP 엔드포인트에 인증이 필요한지 유무도 확인해야 함

### 프로브를 가볍게 유지하기
* 라이브니스 프로브는 너무 많은 연산 리소스를 사용해서는 안 되며, 완료하는데 너무 오래 걸리지 않아야 한다.
* 기본적으로 프로브는 비교적 자주 실행되며 1초 내에 완료돼야 한다.

### 프로브에 재시도 루프를 구현하지 마라
* 프로브에 자체적인 재시도 루프를 구현하는 것은 헛수고다.

### 라이브니스 프로브 요약
* 라이브니스 프로브 실패시 컨테이너 재실행은 파드를 호스팅하는 노드의 Kubelet 에서 수행
  * 마스터에서 실행 중인 쿠버네티스 컨트롤 플레인 구성 요소는 이 프로세스에 관여하지 않는다.
* 노드 자체에 크래시가 발생한 경우 노드 크래시로 중단된 모든 파드의 대체 파드를 생성해야 하는 것은 컨트롤 플레인의 역할
* 직접 생성한 파드는 Kubelet 에 의해서 관리되는데, Kubelet 은 노드에서 실행되기 때문에 노드가 고장나면 아무것도 못한다.
* 애플리케이션이 다른 노드에서 재시작되도록 하려면 레플리케이션컨트롤러 등으로 파드를 관리해야 한다.

---